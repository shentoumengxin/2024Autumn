# Assembly language

以 x86系统 （8086 8088）进行学习

## CPU 

我们可以把CPU物理结构逻辑化

### 三类总线

* 地址总线

  宽度为N，寻址空间 2^n^ 

  带宽决定内存空间地址

  * RAM空间 （random access memory）

    主板上的，扩展槽上的（显卡）

  * ROM（Read only memory）

    系统BIOS，接口卡的BIOS

* 控制总线

  对内存空间发出传递控制命令，读/写

  

* 数据总线

  接收/传输数据

### 计算机内存地址空间

IO接口都存在一个控制卡，对外接设备进行控制，CPU通过总线控制控制卡从而实现连接。

接口卡，显卡，网卡，都存在ROM，也有相应的BIOS系统。

CPU通过总线链接所有的内存空间。

## 环境配置

DOSBOX Dos环境

## 寄存器

进行信息存储

### 通用寄存器

AX,BX,CX,DX. x8086CPU 16位寄存器.

每一个AX还可以分为AH和AL两个8位寄存器，代表两个2位的16进制的数。

**分别操作时二者看作两个独立的空间** 也就是说不会进位

### Move ax bx

把bx的值移动到ax

Add ax 10

ax加10赋值到ax中

**注意！！！** 操作时溢出会溢出高位，且只能操作相同位宽数据

### 物理地址

内存单元有唯一的线性地址空间，叫做物理地址。

其大小由地址总线宽度决定，且不一定与cpu位相等！

### 16位的CPU

* 运算器一次最多处理16位数据
* 寄存器最大宽度16
* 寄存器与运算器通路为16

### 段地址与偏移地址

例如x8086地址总线20位

cpu会产生一个段地址和一个偏移地址，通过地址加法器合成20位，从而实现对地址总线控制

$物理地址=段地址*16+偏移地址$

也可以说段地址左移4位再加偏移地址得到物理地址。

可以通过**段地址进行分段**，即地址的分段来自cpu的段地址。

### 段寄存器

CS  DS SS ES

## CS IP寄存器

储存的是执行命令的内存位置的段地址和偏移地址。

a：修改    t: 按照cs：ip依次执行

 r： 查看寄存器/加上具体内存地址（以数据查看内存）   u： 以命令查看内存内容

jmp：把当前的cs:ip 跳到指定的内存空间

## 字和字的传输

如何联系 内存和cpu寄存器

### 内存中的字

16位处理器代表一个字是16位存储。

数据总线是16位，一整个寄存器可以存16位，且分为高位低位

每一个内存单元只能存8位！

高位存在高地址，低位在低地址，连续存储，每个存一个16进制的数（4byte）

### 内存单元储存数据

用DS 和 [adress] 配合（段，偏移）合成物理地址

eg：

```assembly
mov bx 1000H
mov ds,bx   //!!!不可以直接对ds赋值
mov al,[0]  
// 10000H的数据读取到al中
mov bx 1000H
mov ds,bx
mov [0],ax
//ax 赋值到（1000:0）
```

如何读入一个字？

```assembly
mov ax 1000H
mov dx,ax
mov ax,[0]
mov bx,[1]
add 
```

## CPU stack 机制

### 栈地址寄存器

**SS:SP** 指向栈顶元素

push ax 把ax数据入栈(地址由高向低)

1. **SP=SP-2**

2. ax 送入SS:SP 的内存中

pop ax 把栈顶元素取出，存储到ax

SS:SP 内容输送到ax

SP=SP+2



## 程序

我们用edit进行写代码（1.asm），masm进行编译(1.obj)，link进行连接(1.exe).

```assembly
assume cs:codesg
codesg segment
	mov ax,2
	add ax,ax
	add ax,ax
	
	mov ax,4c00H
	int 21H     //return 
codesg ends
end
```

对于操作系统，需要有一个已经运行的程序P1把可执行代码P2存入内存，再改变CS指向代码段。

DOS 操作系统的shell(command.com)就是这个程序P1,程序return的作用就是回到shell。

debug可以在程序运行的同时，debug同步运行，所以可以看到内存信息。













 